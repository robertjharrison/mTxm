import sys
import os
import math
import importlib

import tune

def print_help():
    print("""
Usage: python3 gen.py target [tuning data file name]")

    target.py     Name of the python module defining the target architecture
                  (i.e., the name of a python script omitting the trailing '.py').
                  Example targets include: 'neon', 'avx2', 'avx512', 'sve'.

    tuning data   Optionally provide the name of a file containing tuning
                  data generated by running the tuner executable
                  (e.g., 'tune_graviton.txt', 'tune_haswell.txt', 'tune_skylake.txt')
""")

if len(sys.argv) == 2:
    target = sys.argv[1]
    tuningdata = "none"
    #print("Generating for target '%s' with default tuner"%target)
elif len(sys.argv) == 3:
    target = sys.argv[1]
    tuningdata = sys.argv[2]
    #print("Generating for target '%s' with tuning data from '%s'"%(target,tuningdata))
else:
    print_help()
    sys.exit(1)

arch =  importlib.import_module(target)


#################################################

def intceil(x):
    ''' Ceiling of floating point value as an integer '''
    return int(math.ceil(x))

tab="   ";

def b(j):
    '''Name of b register from j register index '''
    return "bkj%2.2d"%j

def c(i,j):
    ''' Name of c register from i tile index and j register index'''
    return "ci%2.2dj%2.2d"%(i,j)

def kernel_name(itile,jtile):
    ''' Name of kernel from i/j tile sizes '''
    return "kernel_i%2.2d_j%2.2d"%(itile,jtile)

def print_opening(itile,jtile):
    ''' Print the stuff at the beginning of a kernel ''' 
    print("\nstatic void %s(const int dimi,const int dimj,const int dimk,%s* __restrict__ c,int incC,const %s* a,int incA,const %s* b,int incB, bool firstk) {" % (kernel_name(itile,jtile),arch.DATA_TYPE,arch.DATA_TYPE,arch.DATA_TYPE))
    indent=tab
    print(indent,"const int itile=%d;"%itile)
    print(indent,"const int jtile=%d;"%jtile)
    print(indent,'if (kernel_trace) std::cout << "%s: dimi=" << dimi << " dimj=" << dimj << " dimk=" << dimk << " incA=" << incA << " incB=" << incB << " incC=" << incC << std::endl;' % kernel_name(itile,jtile))
    print(indent,"calls[itile][jtile]+=2.0*dimi*dimj*dimk;")
    
def decl_jreg(indent,basename,njreg):
    ''' declare a vector of registers over j index '''
    print(indent,arch.REGISTER_TYPE," ",end="")
    for j in range(njreg):
        print("%s%2.2d"%(basename,j),end="")
        if (j == (njreg-1)):
            print(";")
        else:
            print(",",end="")


def print_nounroll():
    ''' Print pragma to prevent loop unrolling that is usually detrimental to performance '''
    print('''
#ifdef __clang__
#pragma clang loop unroll_count(1)
#elif defined(__INTEL_COMPILER)
// must be before GNUC since intel also defines this?
#pragma nounroll
#elif defined(__GNUC__)
#pragma GCC unroll 1
#else
#error "failed to detect compiler to stop loop unrolling"            
#endif''')
            
def gen(itile,jtile):
    ''' Generate a kernel for given itile and jtile sizes'''
    njreg=intceil(jtile/arch.REGISTER_WIDTH)

    # open function kernel_itile_jtile
    print_opening(itile,jtile)
    indent=tab
    arch.decl_mask(indent,jtile);

    # loop over j tiles
    print(indent,"for (int j=0; j<dimj; j+=jtile,c+=jtile,b+=jtile) {")
    indent=2*tab
    
    # loop over i tiles
    print(indent,"%s* __restrict__ pcij=c;"%arch.DATA_TYPE)
    print(indent,"for (int i=0; i<dimi; i+=itile,pcij+=itile*incC) {")
    indent=3*tab
    print(indent,"const %s* pbkj=b;"%arch.DATA_TYPE)
    print(indent,"const %s* paki=a+i;"%arch.DATA_TYPE)

    # declare registers
    print(indent,"%s aki;" % arch.REGISTER_TYPE)
    decl_jreg(indent,"bkj",njreg);

    for i in range(itile):
        decl_jreg(indent,"ci%2.2dj"%i,njreg)

    ## # zero C registers --- eliminated by peeling first loop of k
    ## for i in range(itile):
    ##     print(indent+" ",end="")
    ##     for j in range(njreg):
    ##         zero(c(i,j))
    ##     print("")

    # if firstk peel off first loop of k replacing fma with mul, otherwise load c
    print(indent, "if (firstk) {")
    indent=4*tab
    print(indent+" ",end="")
    for j in range(njreg):
        is_incomplete = j==(njreg-1)and(jtile%arch.REGISTER_WIDTH)
        arch.load(b(j),"pbkj+%d"%(j*arch.REGISTER_WIDTH),is_incomplete);  ############# HERE don't +j if j==0
    print("");
    for i in range(itile):
        arch.broadcast(indent,"aki","paki+%2d"%i)                         ############# HERE don't +i if i==0
        for j in range(njreg):
            arch.mul("aki",b(j),c(i,j))
        print("")
    print(indent,"pbkj+=incB,paki+=incA;");
    indent=3*tab
    print(indent,"} else {")
    indent=4*tab
    for i in range(itile):
        print(indent+" ",end="")
        for j in range(njreg):
            is_incomplete = j==(njreg-1)and(jtile%arch.REGISTER_WIDTH)        
            arch.load(c(i,j),"pcij+incC*%2d+%d"%(i,j*arch.REGISTER_WIDTH),is_incomplete)
        print("")
    indent=3*tab
    print(indent,"}")
    
    print(indent,'__asm__("/*start %s inner loop*/");'%kernel_name(itile,jtile))
    # loop over remainder of k
    #### for when we peel off front loop print(indent,"pbkj+=incB,paki+=incA;")
    print_nounroll()
    print(indent,"for (int k=int(firstk); k<dimk; k++,pbkj+=incB,paki+=incA) {")
    indent=4*tab

    # load b
    print(indent+" ",end="")
    for j in range(njreg):
        is_incomplete = j==(njreg-1)and(jtile%arch.REGISTER_WIDTH)        
        arch.load(b(j),"pbkj+%d"%(j*arch.REGISTER_WIDTH),is_incomplete);
    print("");

    # finally do some computation
    for i in range(itile):
        arch.broadcast(indent,"aki","paki+%2d"%i)
        for j in range(njreg):
            arch.fma("aki",b(j),c(i,j))
        print("")
    indent=3*tab
    print(indent,"}")
    print(indent,'__asm__("/*end %s*/");'%kernel_name(itile,jtile))
    

    # store C
    for i in range(itile):
        print(indent+" ",end="")
        for j in range(njreg):
            is_incomplete = j==(njreg-1)and(jtile%arch.REGISTER_WIDTH)        
            arch.store(c(i,j),"pcij+incC*%2d+%d"%(i,j*arch.REGISTER_WIDTH),is_incomplete)
        print("")

    indent=2*tab
    print(indent,"}")
    indent = tab
    print(indent,"}")
    print("}")

arch.print_include()
print("static bool kernel_trace = false;")
print("void set_kernel_trace(bool value){kernel_trace=value;}")
print("using kernelT = void (*)(const int dimi,const int dimj,const int dimk,double* __restrict__ c,int incC,const double* a,int incA,const double* b,int incB,bool firstk);")
print("static const int MAX_ITILE=%d, MAX_JTILE=%d;" % (arch.MAX_ITILE,arch.MAX_JTILE))
print("static const int TARGET_ITILE=%d;"%arch.TARGET_ITILE)
print("static const int TARGET_JTILE=%d;"%arch.TARGET_JTILE)
print("static const int REGISTER_WIDTH=%d;"%arch.REGISTER_WIDTH)
print("static const int MASK_IN_REGISTER=%d;"%arch.MASK_IN_REGISTER)
print("static const int NUMBER_OF_REGISTERS=%d;"%arch.NUMBER_OF_REGISTERS)

print("static double calls[MAX_ITILE+1][MAX_JTILE+1] = {{0.0}};")
print("static kernelT dispatch[MAX_ITILE+1][MAX_JTILE+1] = {{nullptr}};")


# When generating the kernels permit use a of few more registers than actually
# exist since sometimes the compiler can do something creative like swtiching
# to use data directly from cache ... must match loop in search

# This loop nest must match the one immediately below
for jtile in range(1,arch.MAX_JTILE+1):
    jr = (jtile-1)//arch.REGISTER_WIDTH + 1
    maxitile = min((arch.NUMBER_OF_REGISTERS-1)//jr-1 +2,arch.MAX_ITILE)
    for itile in range(1,maxitile+1):
        gen(itile,jtile)

print("\nstatic void init_dispatch() {")
for jtile in range(1,arch.MAX_JTILE+1):
    jr = (jtile-1)//arch.REGISTER_WIDTH + 1
    maxitile = min((arch.NUMBER_OF_REGISTERS-1)//jr-1 +2,arch.MAX_ITILE)
    for itile in range(1,maxitile+1):
        print(tab,"dispatch[%2d][%2d]=&%s;"%(itile,jtile,kernel_name(itile,jtile)))
print("}")

print('''
static inline kernelT kernel(int itile, int jtile) {
  if (itile<0 || itile>MAX_ITILE) {std::cerr<<itile<<std::endl; throw "bad itile dispatching kernel";}
  if (jtile<0 || jtile>MAX_JTILE) {std::cerr<<jtile<<std::endl; throw "bad jtile dispatching kernel";}
  kernelT f = dispatch[itile][jtile];
  if (!f) {std::cerr << itile << " " << jtile << std::endl; throw "kernel not found dispatching kernel";}
  return f;
}
''')


if tuningdata == 'none':
    arch.print_tuner()
else:
    tune.print_tuner(arch,tuningdata)

print('''

// This routine is always called with dimi and dimj a multiple of the corresponding tile size
static void mTxmqX(int dimi, int dimj, int dimk, double* __restrict__ c, int incC, const double* a, int incA, const double* b, int incB, int itile, int jtile) {

  const int target_reuse_factor = 3;  
  const int ktile_cache = std::min(dimk, (%(CACHE_SIZE)s - itile*jtile) / (std::min(target_reuse_factor*itile,dimi)+std::min(target_reuse_factor*jtile,dimj)));
  //const int ktile_cache = std::min(%(TARGET_KTILE)s,dimk);

  int reuse_factor = (%(CACHE_SIZE)s - itile*jtile) / ktile_cache;
  int itile_cache = std::min(reuse_factor*itile,dimi);
  int jtile_cache = std::min(reuse_factor*jtile,dimj);

  const double* const asave = a;
  const double* bsave = b;
  double* __restrict__ csave = c;

  auto f = kernel(itile,jtile);

  int numj = dimj;
  while (numj) {
    int nj = std::min(numj,jtile_cache);
 
    bool firstk = true;
    int numk = dimk;
    while (numk) {
      int nk = std::min(numk,ktile_cache);

      const double* ak = asave;
      int numi = dimi;
      while (numi) {
        int ni = std::min(numi,itile_cache);
        
        (*f)(ni, nj, nk, c, incC, a, incA, b, incB, firstk);

        a += ni;
        c += ni*incC;
        numi -= ni;
      }
      firstk = false;
      a = ak += nk*incA;
      b += nk*incB;
      c = csave;
      numk -= nk;
    }
    a = asave;
    b = bsave += nj;
    c = csave += nj;
    numj -= nj;
  }
}

void mTxmqG(int dimi, int dimj, int dimk, double* __restrict__ c, const double* a, const double* b, int itile=-1, int jtile=-1) {
  static bool initialized = false;
  if (!initialized) {
    init_dispatch();
    initialized=true;
  }

  const int incA = dimi;
  const int incB = dimj;
  const int incC = dimj;

  if (itile==-1 || jtile==-1) tune(dimi,dimj,dimk,itile,jtile);

  // Figure out i tiling
  std::div_t di = std::div(dimi,itile); 
  int nitile = di.quot;   // No. of i tiles
  int ni0 = nitile*itile; // Total size of complete tiles
  int ni1 = di.rem;       // Remainder

  // Figure out j tiling
  std::div_t dj = std::div(dimj,jtile);
  int njtile = dj.quot;
  int nj0 = njtile*jtile;
  int nj1 = dj.rem;

  // Multiply each block

  if (ni0 && nj0) mTxmqX(ni0, nj0, dimk, c, incC, a, incA, b, incB, itile, jtile);

  if (ni0 && nj1) mTxmqX(ni0, nj1, dimk, c+nj0, incC, a, incA, b+nj0, incB, itile, nj1); // Redoing the tiling might help

  if (ni1 && nj0) mTxmqX(ni1, nj0, dimk, c+ni0*incC, incC, a+ni0, incA, b, incB, ni1, jtile);  // Redoing the tiling might help

  if (ni1 && nj1) mTxmqX(ni1, nj1, dimk, c+ni0*incC+nj0, incC, a+ni0, incA, b+nj0, incB, ni1, nj1); // Know these tiles fit
}
''' % {"TARGET_KTILE":arch.TARGET_KTILE, "CACHE_SIZE":arch.CACHE_SIZE})


f = open("mTxmq.h","w")
f.write("extern void set_kernel_trace(bool);\n")
f.write("extern void mTxmqG(int dimi, int dimj, int dimk, double* __restrict__ c, const double* a, const double* b, int itile=-1, int jtile=-1);\n")
f.write("static const int MAX_ITILE=%d, MAX_JTILE=%d;\n" % (arch.MAX_ITILE,arch.MAX_JTILE))
f.write("static const int TARGET_ITILE=%d;\n"%arch.TARGET_ITILE)
f.write("static const int TARGET_JTILE=%d;\n"%arch.TARGET_JTILE)
f.write("static const int REGISTER_WIDTH=%d;\n"%arch.REGISTER_WIDTH)
f.write("static const int MASK_IN_REGISTER=%d;\n"%arch.MASK_IN_REGISTER)
f.write("static const int NUMBER_OF_REGISTERS=%d;\n"%arch.NUMBER_OF_REGISTERS)
f.close()
